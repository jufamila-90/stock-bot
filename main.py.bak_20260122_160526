import os, time, json, re, datetime
import concurrent.futures
from io import StringIO

import pytz
import schedule
import feedparser
import requests
import pandas as pd
import yfinance as yf
import gspread
import FinanceDataReader as fdr

from oauth2client.service_account import ServiceAccountCredentials
from dotenv import load_dotenv

import google.generativeai as genai
try:
    from gspread_formatting import *  # noqa
    HAS_GSPREAD_FORMATTING = True
except Exception as e:
    HAS_GSPREAD_FORMATTING = False
    print(f"âš ï¸ gspread_formatting ë¹„í™œì„±í™”: {e}")

# ==============================================================================
# V33.1 (Radar + KIS US Trading + Latency Guard)
# - KR/US 24ì‹œê°„ ì •ë³´ ìˆ˜ì§‘(ë‰´ìŠ¤ + ë ˆì´ë”)
# - ì‹œì¥ ì—´ë¦¬ë©´ ìë™ë§¤ë§¤ ì‹¤í–‰
# - ì£¼ë¬¸ ì§ì „ KIS í˜„ì¬ê°€ë¡œ êµì°¨ê²€ì¦(ë”œë ˆì´ ë°©ì–´)
# ==============================================================================

VERSION = "V33.1 (Radar+KIS-US+LatencyGuard)"

TZ_KR = pytz.timezone("Asia/Seoul")
TZ_ET = pytz.timezone("America/New_York")

STATE_FILE = "bot_state.json"
SERVICE_ACCOUNT_FILE = "service_account.json"

# êµ¬ê¸€ì‹œíŠ¸: ì´ë¦„(open) ëŒ€ì‹  ID(open_by_key)ë¡œ ê³ ì • ê°€ëŠ¥
SPREADSHEET_NAME = "AI_Trading_Journal_NEW"  # fallback
SPREADSHEET_ID = ""   # .env ë¡œë“œ í›„ ì„¸íŒ…
WS_TRADES = "ì£¼ì‹ë‚´ì—­"
WS_AI_LOG = "AI_ê²€ì¦_ê¸°ë¡"
WS_DASHBOARD = "Dashboard"

# ----------------------------
# .env ë¡œë“œ
# ----------------------------
load_dotenv()


# --- Sheet heartbeat (runtime write check) ---
LAST_SHEET_HEARTBEAT = 0
SHEET_HEARTBEAT_SEC = int(os.getenv("SHEET_HEARTBEAT_SEC", "180"))

def sheet_heartbeat():
    """WS_AI_LOGì— ì£¼ê¸°ì ìœ¼ë¡œ 'alive' ê¸°ë¡. (ìš´ì˜ì—ì„œ í•„ìˆ˜)"""
    global LAST_SHEET_HEARTBEAT
    if not GSHEET:
        return
    try:
        import time
        now = time.time()
        if now - LAST_SHEET_HEARTBEAT < SHEET_HEARTBEAT_SEC:
            return
        LAST_SHEET_HEARTBEAT = now
        ts = now_kr().strftime("%Y-%m-%d %H:%M:%S")
        ws = GSHEET.worksheet(WS_AI_LOG)
        ws.append_row([ts, "SYS", "HEARTBEAT", "alive"], value_input_option="USER_ENTERED")
        print("âœ… HEARTBEAT appended")
    except Exception as e:
        print(f"âš ï¸ HEARTBEAT ì‹¤íŒ¨: {e}")

GEMINI_KEY = os.getenv("GEMINI_KEY", "")
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN", "")
CHAT_ID = os.getenv("CHAT_ID", "")

# --- Google Sheet ê³ ì •(ê¶Œì¥) ---
SPREADSHEET_ID = os.getenv("SPREADSHEET_ID", "")
WS_TRADES = os.getenv("WS_TRADES", "ì£¼ì‹ë‚´ì—­")
WS_AI_LOG = os.getenv("WS_AI_LOG", "AI_ê²€ì¦_ê¸°ë¡")
WS_DASHBOARD = os.getenv("WS_DASHBOARD", "Dashboard")

KIS_APP_KEY = os.getenv("KIS_APP_KEY", "")
KIS_APP_SECRET = os.getenv("KIS_APP_SECRET", "")
KIS_CANO = os.getenv("KIS_CANO", "")
KIS_ACNT_PRDT_CD = os.getenv("KIS_ACNT_PRDT_CD", "01")

KIS_ENV = os.getenv("KIS_ENV", "VIRTUAL").upper()  # VIRTUAL / REAL
KIS_DOMAIN_REAL = os.getenv("KIS_DOMAIN_REAL", "https://openapi.koreainvestment.com:9443")
KIS_DOMAIN_VIRTUAL = os.getenv("KIS_DOMAIN_VIRTUAL", "https://openapivts.koreainvestment.com:29443")

def kis_domain() -> str:
    return KIS_DOMAIN_VIRTUAL if KIS_ENV == "VIRTUAL" else KIS_DOMAIN_REAL

# ==============================================================================
# ë¦¬ìŠ¤í¬/ìš´ì˜ íŒŒë¼ë¯¸í„°
# ==============================================================================
# ê±°ë˜ ëª¨ë“œ:
# - DRY_RUN=True : ì£¼ë¬¸ API í˜¸ì¶œ ìì²´ë¥¼ ì•ˆ í•¨(ì™„ì „ ëª¨ì˜)
# - DRY_RUN=False & KIS_ENV=VIRTUAL : KIS ëª¨ì˜íˆ¬ì ê³„ì¢Œë¡œ "ì§„ì§œ ì£¼ë¬¸" í˜¸ì¶œ(ê¶Œì¥ í…ŒìŠ¤íŠ¸)
# - DRY_RUN=False & KIS_ENV=REAL : ì‹¤ì „ ì£¼ë¬¸
DRY_RUN = False

MAX_POSITIONS = 6
MAX_RETRIES_PER_DAY = 3

# ì†ìµ/ë¦¬ìŠ¤í¬
MAX_DAILY_LOSS_KRW = -500000
STOP_LOSS_PCT = -0.05
TAKE_PROFIT_PCT = 0.15

# ìê¸ˆ/ë¹„ì¤‘
VIRTUAL_CASH_KRW = 10_000_000
USE_EQUITY_RATIO = False
INVEST_PER_TRADE_KRW = 1_000_000
EQUITY_RATIO_PER_TRADE = 0.05

MIN_TRADE_KRW = 500_000
MAX_TRADE_KRW = 3_000_000
MAX_TRADE_PCT = 0.10

SCALING_BUY_STEPS = [0.3, 0.3, 0.4]
SCALING_SELL_STEPS = [0.5, 0.5]

# ìœ ë™ì„± í•„í„°
MIN_VOLUME_KRW = 1_400_000_000  # 14ì–µ

# ì§€ì—° ë°©ì–´(êµì°¨ê²€ì¦)
# - YF ë¶„ì„ê°€ vs KIS ì‹¤ì‹œê°„ê°€ ê´´ë¦¬(%)ê°€ ì´ ê°’ ì´ìƒì´ë©´ ì£¼ë¬¸ ì·¨ì†Œ/ì¶•ì†Œ
LATENCY_GUARD_SOFT = 0.007   # 0.7% ì´ìƒì´ë©´ ê²½ê³  + KISê°€ë¡œ êµì²´
LATENCY_GUARD_HARD = 0.02    # 2.0% ì´ìƒì´ë©´ ì£¼ë¬¸ ìŠ¤í‚µ

# í™˜ìœ¨
EXCHANGE_RATE = 1450.0

# ==============================================================================
# ì „ì—­ ìƒíƒœ
# ==============================================================================
ACCESS_TOKEN = ""
ACCESS_TOKEN_EXPIRES_AT = 0  # epoch seconds

GSHEET = None

SEEN_LINKS = {}  # {link: last_seen_epoch}
SEEN_TTL_SEC = 60 * 60 * 48  # 48ì‹œê°„

KR_TICKER_MAP = {}  # name/code -> 005930.KS / .KQ

PORTFOLIO = {}  # {ticker: {qty, avg_price, market, step, half_sold, trade_type, exch}}
TODAY_PROFIT_KRW = 0
DAILY_TRADE_COUNT = {}
LAST_RESET_DATE = None

# ì¥ì´ ë‹«í˜€ë„ "ì¢‹ì€ ì‹œê·¸ë„"ì„ ì ì¬í–ˆë‹¤ê°€, ì¥ ì—´ë¦¬ë©´ ì‹¤í–‰
PENDING_SIGNALS = []  # list of {ts, market, ticker, score, reason, trade_type, exch}

# ==============================================================================
# [V40 PATCH] Observability + Proportional Sizing + Vol Targeting
# - (V33.1 ë³‘ëª© í•´ê²°) OB í•˜ë“œí•„í„° ë•Œë¬¸ì— ë§¤ìˆ˜ 0ì´ ë˜ëŠ” ë¬¸ì œë¥¼ 'ì†Œí”„íŠ¸ ìŠ¤ì½”ì–´'ë¡œ ì™„í™”
# - (ì±… í•µì‹¬ ë°˜ì˜) ì ìˆ˜ ê¸°ë°˜ ë¹„ë¡€ë°°ë¶„ + (US) ë³€ë™ì„± íƒ€ê²ŸíŒ… + ì´ì¤‘ ì†ì ˆ(ì ˆë°˜/ì „ëŸ‰)
# - (ìš´ì˜ í•µì‹¬) ì™œ ë§¤ìˆ˜ê°€ ì•ˆ ëëŠ”ì§€ DROP ì‚¬ìœ ë¥¼ ì§‘ê³„/ìƒ˜í”Œë¡œ ì¶œë ¥
# ==============================================================================
from collections import defaultdict, deque

OBS = {
    "kpi": defaultdict(int),
    "drop": defaultdict(int),
    "samples": defaultdict(lambda: deque(maxlen=5)),
    "last_print": 0,
}
OBS_PRINT_INTERVAL_SEC = 180  # 3ë¶„

def obs_inc(key: str, n: int = 1):
    OBS["kpi"][key] += n

def obs_drop(reason: str, market=None, ticker=None, score=None, extra=None):
    OBS["drop"][reason] += 1
    OBS["samples"][reason].append({
        "m": market,
        "t": ticker,
        "s": score,
        "x": extra if extra is not None else {},
    })

def obs_maybe_print():
    now = time.time()
    if now - OBS["last_print"] < OBS_PRINT_INTERVAL_SEC:
        return
    OBS["last_print"] = now

    top = sorted(OBS["drop"].items(), key=lambda x: x[1], reverse=True)[:10]
    print("ğŸ“Š [KPI]", dict(OBS["kpi"]))
    print("ğŸ§± [DROP_TOP]", top)
    for r, _ in top[:3]:
        print(f"ğŸ§ª [SAMPLE {r}]", list(OBS["samples"][r])[-3:])


def market_vol_proxy_us():
    """QQQ ìµœê·¼ 20ì¼ ì¼ê°„ ë³€ë™ì„±(í‘œì¤€í¸ì°¨)"""
    try:
        df = yf.Ticker("QQQ").history(period="2mo", interval="1d")
        if df is None or df.empty or len(df) < 25:
            return None
        rets = df["Close"].pct_change().dropna()
        return float(rets.tail(20).std())
    except:
        return None


def vol_target_multiplier(market: str):
    """ë³€ë™ì„±â†‘ -> íˆ¬ìê¸ˆâ†“ (USë§Œ ì ìš©)"""
    if market != "US":
        return 1.0
    target = 0.016  # 1.6%
    vol = market_vol_proxy_us()
    if not vol:
        return 1.0
    mult = target / vol
    return max(0.4, min(1.2, mult))


def calc_amount_proportional(soft_score: float, market: str):
    """(ì±… ë°˜ì˜) Proportional Rule + Vol Targeting"""
    BUY_SCORE_MIN = 82
    s = max(BUY_SCORE_MIN, min(100.0, float(soft_score)))
    alpha = (s - BUY_SCORE_MIN) / (100.0 - BUY_SCORE_MIN)  # 0~1

    base = MIN_TRADE_KRW + alpha * (MAX_TRADE_KRW - MIN_TRADE_KRW)
    base *= vol_target_multiplier(market)

    eq = calc_equity()
    base = min(base, eq * MAX_TRADE_PCT, VIRTUAL_CASH_KRW)
    base = max(base, MIN_TRADE_KRW)
    return int(base)
# ==============================================================================
# Gemini
# ==============================================================================
if GEMINI_KEY:
    genai.configure(api_key=GEMINI_KEY)
model = genai.GenerativeModel("gemini-2.0-flash-exp") if GEMINI_KEY else None

# ==============================================================================
# [1] ìœ í‹¸
# ==============================================================================
def now_kr():
    return datetime.datetime.now(TZ_KR)

def now_et():
    return datetime.datetime.now(TZ_ET)

def send_telegram(msg: str):
    if not TELEGRAM_TOKEN or not CHAT_ID:
        print("âš ï¸ TELEGRAM ì„¤ì • ì—†ìŒ")
        return
    try:
        requests.post(
            f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage",
            data={"chat_id": CHAT_ID, "text": msg},
            timeout=8
        )
    except Exception as e:
        print(f"âš ï¸ í…”ë ˆê·¸ë¨ ì „ì†¡ ì‹¤íŒ¨: {e}")

def prune_seen_links():
    cutoff = int(time.time()) - SEEN_TTL_SEC
    dead = [k for k, v in SEEN_LINKS.items() if v < cutoff]
    for k in dead:
        del SEEN_LINKS[k]

def safe_float(x, default=None):
    try:
        if x is None:
            return default
        return float(x)
    except:
        return default

def safe_int(x, default=0):
    try:
        return int(float(x))
    except:
        return default

# ==============================================================================
# [2] ìƒíƒœ ì €ì¥/ë³µì› (Persistence)
# ==============================================================================
def save_state():
    global LAST_RESET_DATE
    try:
        data = {
            "virtual_cash": VIRTUAL_CASH_KRW,
            "portfolio": PORTFOLIO,
            "today_profit": TODAY_PROFIT_KRW,
            "daily_trade_count": DAILY_TRADE_COUNT,
            "last_reset_date": LAST_RESET_DATE.isoformat() if LAST_RESET_DATE else None,
            "seen_links": SEEN_LINKS,
            "pending_signals": PENDING_SIGNALS,
            "exchange_rate": EXCHANGE_RATE,
            "kis_env": KIS_ENV,
            "dry_run": DRY_RUN,
        }
        with open(STATE_FILE, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False)
    except Exception as e:
        print(f"âš ï¸ save_state ì—ëŸ¬: {e}")

def load_state():
    global VIRTUAL_CASH_KRW, PORTFOLIO, TODAY_PROFIT_KRW, DAILY_TRADE_COUNT, LAST_RESET_DATE
    global SEEN_LINKS, PENDING_SIGNALS, EXCHANGE_RATE
    if not os.path.exists(STATE_FILE):
        print("â„¹ï¸ ì €ì¥ëœ ìƒíƒœ íŒŒì¼ ì—†ìŒ (ì²˜ìŒ ì‹¤í–‰)")
        return
    try:
        with open(STATE_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
        VIRTUAL_CASH_KRW = data.get("virtual_cash", VIRTUAL_CASH_KRW)
        PORTFOLIO = data.get("portfolio", {})
        TODAY_PROFIT_KRW = data.get("today_profit", 0)
        DAILY_TRADE_COUNT = data.get("daily_trade_count", {})
        d = data.get("last_reset_date")
        if d:
            LAST_RESET_DATE = datetime.date.fromisoformat(d)
        SEEN_LINKS = data.get("seen_links", {})
        PENDING_SIGNALS = data.get("pending_signals", [])
        EXCHANGE_RATE = safe_float(data.get("exchange_rate"), EXCHANGE_RATE)
        print(f"âœ… ìƒíƒœ ë³µì› ì™„ë£Œ (ê°€ìƒí˜„ê¸ˆ: {int(VIRTUAL_CASH_KRW):,}ì›, ë³´ìœ ì¢…ëª©: {len(PORTFOLIO)}ê°œ, Pending: {len(PENDING_SIGNALS)}ê°œ)")
    except Exception as e:
        print(f"âš ï¸ load_state ì—ëŸ¬: {e}")

# ==============================================================================
# [3] êµ¬ê¸€ ì‹œíŠ¸ ë¡œê·¸
# ==============================================================================
def initialize_sheet():
    global GSHEET
    try:
        scope = [
            "https://spreadsheets.google.com/feeds",
            "https://www.googleapis.com/auth/drive",
        ]
        creds = ServiceAccountCredentials.from_json_keyfile_name(SERVICE_ACCOUNT_FILE, scope)
        client = gspread.authorize(creds)

        # âœ… ì´ë¦„ ëŒ€ì‹  IDë¡œ ê³ ì • (ê°€ì¥ ì•ˆì „)
        if SPREADSHEET_ID:
            GSHEET = client.open_by_key(SPREADSHEET_ID)
        else:
            GSHEET = client.open(SPREADSHEET_NAME)

        # âœ… ê¸°ì¡´ íƒ­ í™•ì¸ ë° í—¤ë” ì„œì‹ ì ìš©
        try:
            ws_ai = GSHEET.worksheet(WS_AI_LOG)
            format_sheet_headers(ws_ai)
        except Exception as e:
            print(f"âš ï¸ AI_LOG íƒ­ ì„œì‹ ì ìš© ì‹¤íŒ¨: {e}")
        
        try:
            ws_trades = GSHEET.worksheet(WS_TRADES)
            format_sheet_headers(ws_trades)
        except Exception as e:
            print(f"âš ï¸ TRADES íƒ­ ì„œì‹ ì ìš© ì‹¤íŒ¨: {e}")
        
        # âœ… Dashboard íƒ­ ìƒì„± (ì—†ìœ¼ë©´ ìë™ ìƒì„±)
        create_dashboard_tab()

        print("âœ… êµ¬ê¸€ ì‹œíŠ¸ ì—°ê²° ì™„ë£Œ (í”„ë¡œí˜ì…”ë„ ì„œì‹ ì ìš©)")
    except Exception as e:
        GSHEET = None
        print(f"âš ï¸ ì‹œíŠ¸ ì—°ê²° ì‹¤íŒ¨: {e}")

def log_ai_thought(market, ticker, score, status, trade_type, reason, source="", yf_price=None, kis_price=None, gap=None, note=""):
    if not GSHEET:
        return
    try:
        ts = now_kr().strftime("%Y-%m-%d %H:%M:%S")
        row = [
            ts, market, ticker, score, status, trade_type, reason, source, note,
            "" if yf_price is None else yf_price,
            "" if kis_price is None else kis_price,
            "" if gap is None else round(gap*100, 3),
        ]
        ws = GSHEET.worksheet(WS_AI_LOG)
        ws.append_row(row)
        
        # âœ… íƒˆë½ ì‚¬ìœ  ì„œì‹ ì ìš© (reason ì—´ì— ìƒ‰ìƒ)
        if status == "DROP" and reason:
            row_number = len(ws.get_all_values())  # ë°©ê¸ˆ ì¶”ê°€ëœ í–‰ ë²ˆí˜¸
            reason_col_index = 7  # reasonì€ 7ë²ˆì§¸ ì—´ (A=1, B=2, ..., G=7)
            apply_drop_reason_formatting(ws, row_number, reason_col_index, reason)
            
    except Exception as e:
        print(f"âš ï¸ log_ai_thought ì—ëŸ¬: {e}")

def find_header_row(ws, required=("ë§¤ë§¤êµ¬ë¶„", "ì¢…ëª©ì½”ë“œ")):
    # í—¤ë”ê°€ 1í–‰ì´ ì•„ë‹ ìˆ˜ ìˆì–´ì„œ 1~5í–‰ì—ì„œ íƒìƒ‰
    for r in range(1, 6):
        vals = ws.row_values(r)
        if vals and all(k in vals for k in required):
            return r, vals
    # fallback
    vals = ws.row_values(1)
    return 1, vals


def log_trade_to_sheet(ts, ticker, market, exch, side, price, qty, pnl, strategy, note=""):
    """
    ì£¼ì‹ê±°ë˜_RAW ì‹œíŠ¸ì— ë§¤ë§¤ ë¡œê·¸ ê¸°ë¡
    - í•œêµ­ ì£¼ì‹ í‹°ì»¤ì— .KS/.KQ ìë™ ì¶”ê°€
    - ê±°ë˜ì¼, ì¦ê¶Œì‚¬, ê³„ì¢Œ, ì¢…ëª©ëª…, Ticker, ë§¤ë§¤êµ¬ë¶„, ìˆ˜ëŸ‰, í†µí™”, í‰ë‹¨ê°€ ë“± ê¸°ë¡
    """
    if not GSHEET:
        return
    try:
        # ì£¼ì‹ê±°ë˜_RAW ì‹œíŠ¸ ì‚¬ìš©
        try:
            ws = GSHEET.worksheet("ì£¼ì‹ê±°ë˜_RAW")
        except:
            # fallback: ê¸°ì¡´ ì‹œíŠ¸ ì´ë¦„ ì‚¬ìš©
            ws = GSHEET.worksheet(WS_TRADES)
        
        _, headers = find_header_row(ws, required=("ë§¤ë§¤êµ¬ë¶„", "Ticker"))
        if not headers:
            print("âš ï¸ ì£¼ì‹ê±°ë˜_RAW í—¤ë”ë¥¼ ì½ì§€ ëª»í•¨")
            return

        row = [""] * len(headers)

        def set_any(names, value):
            for name in names:
                if name in headers:
                    row[headers.index(name)] = value
                    return
        
        # í•œêµ­ ì£¼ì‹ í‹°ì»¤ì— .KS/.KQ ì¶”ê°€
        formatted_ticker = ticker
        if market == "KR":
            if not ticker.endswith(".KS") and not ticker.endswith(".KQ"):
                # KR_TICKER_MAPì—ì„œ í™•ì¸í•˜ì—¬ .KS/.KQ ì¶”ê°€
                if ticker in KR_TICKER_MAP:
                    formatted_ticker = KR_TICKER_MAP[ticker]
                elif re.fullmatch(r"\\d{6}", ticker):
                    # 6ìë¦¬ ìˆ«ìë©´ .KSë¡œ ê°€ì • (ë‚˜ì¤‘ì— .KQë¡œ ìˆ˜ì • í•„ìš”ì‹œ ë³„ë„ ë¡œì§)
                    formatted_ticker = f"{ticker}.KS"
        
        # ì¢…ëª©ëª… ê°€ì ¸ì˜¤ê¸°
        stock_name = ticker
        if market == "KR":
            # KR_TICKER_MAPì—ì„œ ì—­ìœ¼ë¡œ ì°¾ê¸°
            clean_ticker = ticker.replace(".KS", "").replace(".KQ", "")
            for name, t in KR_TICKER_MAP.items():
                if t == formatted_ticker and not re.fullmatch(r"\\d{6}", name):
                    stock_name = name
                    break
        elif formatted_ticker in TICKER_CONFIG:
            stock_name = TICKER_CONFIG[formatted_ticker].get("stock_name", ticker)
        
        # âœ… ì£¼ì‹ê±°ë˜_RAW ì»¬ëŸ¼ ë§¤í•‘
        set_any(["ê±°ë˜ì¼", "ì¼ì", "êµ¬ë§¤ì¼"], ts.split(" ")[0])
        set_any(["ì¦ê¶Œì‚¬", "ë¸Œë¡œì»¤"], os.getenv("BROKER_NAME", "KIS"))
        set_any(["ê³„ì¢Œ"], os.getenv("ACCOUNT_NAME", "KIS01"))
        set_any(["ì¢…ëª©ëª…", "ì¢…ëª©"], stock_name)
        set_any(["Ticker", "ì¢…ëª©ì½”ë“œ", "ì½”ë“œ", "í‹°ì»¤"], formatted_ticker)
        set_any(["ë§¤ë§¤êµ¬ë¶„", "ë§¤ìˆ˜/ë§¤ë„", "ë§¤ìˆ˜Â·ë§¤ë„"], "ë§¤ìˆ˜" if side == "BUY" else "ë§¤ë„")
        set_any(["ìˆ˜ëŸ‰", "ì£¼ìˆ˜"], qty)
        set_any(["í†µí™”", "Currency"], "USD" if market == "US" else "KRW")
        set_any(["í‰ë‹¨ê°€", "ë‹¨ê°€", "ê°€ê²©"], price)
        set_any(["ê¸ˆì•¡"], int(price * qty * (EXCHANGE_RATE if market == "US" else 1)))
        set_any(["í™˜ìœ¨"], EXCHANGE_RATE if market == "US" else 1)
        set_any(["ë¹„ê³ ", "ë©”ëª¨", "ì„¤ëª…"], f"{strategy} | {note}".strip(" |"))

        # âœ… USER_ENTEREDë¡œ ë„£ì–´ì•¼ ì‹œíŠ¸ ìˆ˜ì‹/ì„œì‹ íë¦„ ìœ ì§€
        ws.append_row(row, value_input_option="USER_ENTERED")
        
        # âœ… ê±°ë˜ í–‰ ì¡°ê±´ë¶€ ì„œì‹ ì ìš© (ë§¤ìˆ˜/ë§¤ë„ ìƒ‰ìƒ)
        row_number = len(ws.get_all_values())  # ë°©ê¸ˆ ì¶”ê°€ëœ í–‰ ë²ˆí˜¸
        apply_trade_row_formatting(ws, row_number, side)
        
        # âœ… Dashboard ì§€í‘œ ì—…ë°ì´íŠ¸
        update_dashboard_metrics()
        
        print(f"ğŸ“ ì£¼ì‹ê±°ë˜_RAW ë¡œê¹…: {stock_name}({formatted_ticker}) {side} {qty}ì£¼ @{price}")

    except Exception as e:
        print(f"âš ï¸ log_trade_to_sheet ì—ëŸ¬: {e}")

# ==============================================================================
# [3.5] í”„ë¡œí˜ì…”ë„ ëŒ€ì‹œë³´ë“œ: ì¡°ê±´ë¶€ ì„œì‹ ë° Dashboard íƒ­
# ==============================================================================

def format_sheet_headers(ws):
    """
    ì‹œíŠ¸ì˜ 1í–‰(í—¤ë”)ì— í”„ë¡œí˜ì…”ë„ ì„œì‹ ì ìš©:
    - í‹€ ê³ ì • (Freeze row 1)
    - ë‚¨ìƒ‰ ë°°ê²½ (#1A237E)
    - í°ìƒ‰ êµµì€ ê¸€ì”¨
    - ê°€ìš´ë° ì •ë ¬
    """
    try:
        # í‹€ ê³ ì •: 1í–‰
        set_frozen(ws, rows=1)
        
        # í—¤ë” ì„œì‹
        header_format = CellFormat(
            backgroundColor=Color(0.102, 0.137, 0.494),  # #1A237E (ë‚¨ìƒ‰)
            textFormat=TextFormat(
                bold=True,
                foregroundColor=Color(1, 1, 1)  # í°ìƒ‰
            ),
            horizontalAlignment='CENTER',
            verticalAlignment='MIDDLE'
        )
        
        # 1í–‰ ì „ì²´ì— ì„œì‹ ì ìš©
        format_cell_range(ws, '1:1', header_format)
        
    except Exception as e:
        print(f"âš ï¸ format_sheet_headers ì—ëŸ¬: {e}")


def apply_trade_row_formatting(ws, row_number, side):
    """
    ê±°ë˜ í–‰ì— ì¡°ê±´ë¶€ ì„œì‹ ì ìš©:
    - ë§¤ìˆ˜: ì—°í•œ íŒŒë€ìƒ‰ ë°°ê²½ (#E3F2FD)
    - ë§¤ë„: ì—°í•œ ë¹¨ê°„ìƒ‰ ë°°ê²½ (#FFEBEE)
    """
    try:
        if side == "BUY":
            bg_color = Color(0.89, 0.949, 0.992)  # #E3F2FD (ì—°í•œ íŒŒë€ìƒ‰)
        else:  # SELL
            bg_color = Color(1.0, 0.922, 0.933)  # #FFEBEE (ì—°í•œ ë¹¨ê°„ìƒ‰)
        
        row_format = CellFormat(backgroundColor=bg_color)
        format_cell_range(ws, f'{row_number}:{row_number}', row_format)
        
    except Exception as e:
        print(f"âš ï¸ apply_trade_row_formatting ì—ëŸ¬: {e}")


def apply_drop_reason_formatting(ws, row_number, col_index, reason):
    """
    íƒˆë½ ì‚¬ìœ ë³„ ìƒ‰ìƒ ì ìš©:
    - LOW_SCORE: íšŒìƒ‰ ë°°ê²½ (#E0E0E0)
    - PRICE_GAP: ì£¼í™©ìƒ‰ ë°°ê²½ (#FFE0B2)
    - MAX_POS: ë…¸ë€ìƒ‰ ë°°ê²½ (#FFF9C4)
    """
    try:
        if "LOW_SCORE" in reason:
            bg_color = Color(0.878, 0.878, 0.878)  # #E0E0E0 (íšŒìƒ‰)
        elif "PRICE_GAP" in reason:
            bg_color = Color(1.0, 0.878, 0.698)  # #FFE0B2 (ì£¼í™©ìƒ‰)
        elif "MAX_POS" in reason:
            bg_color = Color(1.0, 0.976, 0.769)  # #FFF9C4 (ë…¸ë€ìƒ‰)
        else:
            return  # ë‹¤ë¥¸ ì‚¬ìœ ëŠ” ì„œì‹ ì ìš© ì•ˆ í•¨
        
        cell_format = CellFormat(backgroundColor=bg_color)
        # ì—´ ì¸ë±ìŠ¤ë¥¼ ë¬¸ìë¡œ ë³€í™˜ (1->A, 2->B, ...)
        col_letter = chr(64 + col_index) if col_index <= 26 else 'A'
        format_cell_range(ws, f'{col_letter}{row_number}', cell_format)
        
    except Exception as e:
        print(f"âš ï¸ apply_drop_reason_formatting ì—ëŸ¬: {e}")


def create_dashboard_tab():
    """
    Dashboard íƒ­ ìƒì„± ë° ì´ˆê¸° ì„¤ì •:
    - ì‹¤ì‹œê°„ ì§€í‘œ ë ˆì´ë¸” ë° ìˆ˜ì‹ ì„¤ì •
    - B2: í˜„ì¬ ì´ ìì‚°
    - B3: ì˜¤ëŠ˜ ëˆ„ì  ìˆ˜ìµë¥  (%)
    - B4: ê¹”ë•Œê¸° í†µê³„ (ì´ ì‹ í˜¸ ëŒ€ë¹„ ìµœì¢… ì£¼ë¬¸ ì„±ê³µë¥ )
    """
    if not GSHEET:
        return
    
    try:
        # Dashboard íƒ­ì´ ì´ë¯¸ ìˆëŠ”ì§€ í™•ì¸
        try:
            ws = GSHEET.worksheet(WS_DASHBOARD)
            print("âœ… Dashboard íƒ­ì´ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤")
            return ws
        except:
            # ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
            ws = GSHEET.add_worksheet(title=WS_DASHBOARD, rows=100, cols=10)
            print("âœ… Dashboard íƒ­ ìƒì„± ì™„ë£Œ")
        
        # í—¤ë” ë° ë ˆì´ë¸” ì„¤ì •
        ws.update('A1', [['ğŸ“Š ì£¼ì‹ ë´‡ ì‹¤ì‹œê°„ ëŒ€ì‹œë³´ë“œ']])
        ws.update('A2', [['í˜„ì¬ ì´ ìì‚° (KRW)']])
        ws.update('A3', [['ì˜¤ëŠ˜ ëˆ„ì  ìˆ˜ìµë¥  (%)']])
        ws.update('A4', [['ê¹”ë•Œê¸° í†µê³„ (ì„±ê³µë¥  %)']])
        
        # ì´ˆê¸°ê°’ ì„¤ì • (ë‚˜ì¤‘ì— update_dashboard_metricsì—ì„œ ì—…ë°ì´íŠ¸)
        ws.update('B2', [[0]])
        ws.update('B3', [[0]])
        ws.update('B4', [[0]])
        
        # í—¤ë” ì„œì‹ ì ìš©
        format_sheet_headers(ws)
        
        # ì œëª© ì„œì‹ (A1)
        title_format = CellFormat(
            backgroundColor=Color(0.102, 0.137, 0.494),
            textFormat=TextFormat(
                bold=True,
                fontSize=14,
                foregroundColor=Color(1, 1, 1)
            ),
            horizontalAlignment='CENTER'
        )
        format_cell_range(ws, 'A1:B1', title_format)
        
        # ë ˆì´ë¸” ì„œì‹ (A2:A4)
        label_format = CellFormat(
            textFormat=TextFormat(bold=True),
            horizontalAlignment='RIGHT'
        )
        format_cell_range(ws, 'A2:A4', label_format)
        
        # ê°’ ì„œì‹ (B2:B4)
        value_format = CellFormat(
            textFormat=TextFormat(fontSize=12),
            horizontalAlignment='LEFT'
        )
        format_cell_range(ws, 'B2:B4', value_format)
        
        return ws
        
    except Exception as e:
        print(f"âš ï¸ create_dashboard_tab ì—ëŸ¬: {e}")
        return None


def update_dashboard_metrics():
    """
    Dashboard íƒ­ì˜ ì‹¤ì‹œê°„ ì§€í‘œ ì—…ë°ì´íŠ¸:
    - B2: í˜„ì¬ ì´ ìì‚° (VIRTUAL_CASH + í‰ê°€ê¸ˆ)
    - B3: ì˜¤ëŠ˜ ëˆ„ì  ìˆ˜ìµë¥  (%)
    - B4: ê¹”ë•Œê¸° í†µê³„ (ì´ ì‹ í˜¸ ëŒ€ë¹„ ìµœì¢… ì£¼ë¬¸ ì„±ê³µë¥ )
    """
    if not GSHEET:
        return
    
    try:
        ws = GSHEET.worksheet(WS_DASHBOARD)
        
        # í˜„ì¬ ì´ ìì‚° ê³„ì‚°
        portfolio_value = 0
        for ticker, info in PORTFOLIO.items():
            qty = info.get('qty', 0)
            avg_price = info.get('avg_price', 0)
            market = info.get('market', 'KR')
            
            # ê°„ë‹¨í•œ í‰ê°€ê¸ˆ ê³„ì‚° (ì‹¤ì œë¡œëŠ” í˜„ì¬ê°€ ì¡°íšŒ í•„ìš”)
            if market == 'US':
                portfolio_value += qty * avg_price * EXCHANGE_RATE
            else:
                portfolio_value += qty * avg_price
        
        total_asset = VIRTUAL_CASH_KRW + portfolio_value
        
        # ì˜¤ëŠ˜ ëˆ„ì  ìˆ˜ìµë¥  ê³„ì‚°
        initial_cash = 10_000_000  # VIRTUAL_CASH_KRW ì´ˆê¸°ê°’
        profit_rate = (TODAY_PROFIT_KRW / initial_cash) * 100 if initial_cash > 0 else 0
        
        # ê¹”ë•Œê¸° í†µê³„ ê³„ì‚°
        total_signals = OBS["kpi"].get("ai_candidates", 0)
        total_orders = OBS["kpi"].get("order_success", 0)
        funnel_rate = (total_orders / total_signals * 100) if total_signals > 0 else 0
        
        # ì—…ë°ì´íŠ¸
        ws.update('B2', [[f'{int(total_asset):,}ì›']])
        ws.update('B3', [[f'{profit_rate:.2f}%']])
        ws.update('B4', [[f'{funnel_rate:.1f}% ({total_orders}/{total_signals})']])
        
    except Exception as e:
        print(f"âš ï¸ update_dashboard_metrics ì—ëŸ¬: {e}")


# ==============================================================================
# [4] í‹°ì»¤ ë¡œë”©
# ==============================================================================
def load_kr_tickers():
    global KR_TICKER_MAP
    try:
        print("ğŸ”„ KRX ì¢…ëª© ë¡œë”© ì¤‘...")
        df_kospi = fdr.StockListing("KOSPI")
        for _, r in df_kospi.iterrows():
            code = str(r["Code"])
            name = r["Name"]
            KR_TICKER_MAP[name] = f"{code}.KS"
            KR_TICKER_MAP[code] = f"{code}.KS"
        df_kosdaq = fdr.StockListing("KOSDAQ")
        for _, r in df_kosdaq.iterrows():
            code = str(r["Code"])
            name = r["Name"]
            KR_TICKER_MAP[name] = f"{code}.KQ"
            KR_TICKER_MAP[code] = f"{code}.KQ"
        print(f"âœ… KRX ë¡œë”© ì™„ë£Œ (ë§µí•‘ {len(KR_TICKER_MAP)}ê°œ)")
    except Exception as e:
        print(f"âš ï¸ KRX ë¡œë”© ì‹¤íŒ¨: {e}")

def normalize_kr_symbol(ticker_or_name: str):
    if ticker_or_name in KR_TICKER_MAP:
        return KR_TICKER_MAP[ticker_or_name]
    if re.fullmatch(r"\d{6}", ticker_or_name):
        return f"{ticker_or_name}.KS"
    return None

# ==============================================================================
# [4.5] êµ¬ê¸€ ì‹œíŠ¸ ì–‘ë°©í–¥ ì—°ë™: Ticker_Info ì»¨íŠ¸ë¡¤ íƒ€ì›Œ
# ==============================================================================
TICKER_CONFIG = {}  # {ticker: {active, target_weight, stop_loss, take_profit, stock_name}}

def load_ticker_config():
    """
    Ticker_Info ì‹œíŠ¸ì—ì„œ ë§¤ë§¤ íŒŒë¼ë¯¸í„°ë¥¼ ì½ì–´ì˜µë‹ˆë‹¤.
    ì»¬ëŸ¼: Ticker, ì¢…ëª©ëª…, Active, ëª©í‘œë¹„ì¤‘, ì†ì ˆê¸°ì¤€, ìµì ˆê¸°ì¤€
    """
    global TICKER_CONFIG
    if not GSHEET:
        print("âš ï¸ ì‹œíŠ¸ ì—°ê²° ì•ˆ ë¨ - Ticker_Info ë¡œë”© ë¶ˆê°€")
        return {}
    
    try:
        ws = GSHEET.worksheet("Ticker_Info")
        all_data = ws.get_all_values()
        
        if not all_data or len(all_data) < 2:
            print("âš ï¸ Ticker_Info ì‹œíŠ¸ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤")
            return {}
        
        headers = all_data[0]
        
        # í—¤ë” ì¸ë±ìŠ¤ ì°¾ê¸°
        try:
            ticker_idx = headers.index("Ticker")
            name_idx = headers.index("ì¢…ëª©ëª…")
        except ValueError as e:
            print(f"âš ï¸ Ticker_Info ì‹œíŠ¸ì— í•„ìˆ˜ ì»¬ëŸ¼ì´ ì—†ìŠµë‹ˆë‹¤: {e}")
            return {}
        
        # ì„ íƒì  ì»¬ëŸ¼ (ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©)
        active_idx = headers.index("Active") if "Active" in headers else None
        weight_idx = headers.index("ëª©í‘œë¹„ì¤‘") if "ëª©í‘œë¹„ì¤‘" in headers else None
        stop_idx = headers.index("ì†ì ˆê¸°ì¤€") if "ì†ì ˆê¸°ì¤€" in headers else None
        profit_idx = headers.index("ìµì ˆê¸°ì¤€") if "ìµì ˆê¸°ì¤€" in headers else None
        
        config = {}
        for row in all_data[1:]:  # í—¤ë” ì œì™¸
            if len(row) <= ticker_idx:
                continue
            
            ticker = row[ticker_idx].strip()
            if not ticker:
                continue
            
            stock_name = row[name_idx] if len(row) > name_idx else ""
            
            # Active (ê¸°ë³¸ê°’: TRUE)
            active = True
            if active_idx and len(row) > active_idx:
                active_val = row[active_idx].strip().upper()
                active = active_val in ("TRUE", "T", "1", "YES", "Y", "")
            
            # ëª©í‘œë¹„ì¤‘ (ê¸°ë³¸ê°’: 10%)
            target_weight = 0.10
            if weight_idx and len(row) > weight_idx:
                weight_str = row[weight_idx].strip().replace("%", "")
                if weight_str:
                    try:
                        target_weight = float(weight_str) / 100.0
                    except:
                        pass
            
            # ì†ì ˆê¸°ì¤€ (ê¸°ë³¸ê°’: -15%)
            stop_loss = -0.15
            if stop_idx and len(row) > stop_idx:
                stop_str = row[stop_idx].strip().replace("%", "")
                if stop_str:
                    try:
                        stop_loss = float(stop_str) / 100.0
                    except:
                        pass
            
            # ìµì ˆê¸°ì¤€ (ê¸°ë³¸ê°’: +30%)
            take_profit = 0.30
            if profit_idx and len(row) > profit_idx:
                profit_str = row[profit_idx].strip().replace("%", "")
                if profit_str:
                    try:
                        take_profit = float(profit_str) / 100.0
                    except:
                        pass
            
            config[ticker] = {
                "active": active,
                "target_weight": target_weight,
                "stop_loss": stop_loss,
                "take_profit": take_profit,
                "stock_name": stock_name,
            }
        
        TICKER_CONFIG = config
        print(f"âœ… Ticker_Info ë¡œë”© ì™„ë£Œ: {len(config)}ê°œ ì¢…ëª©")
        print(f"   Active ì¢…ëª©: {sum(1 for v in config.values() if v['active'])}ê°œ")
        return config
    
    except Exception as e:
        print(f"âš ï¸ Ticker_Info ë¡œë”© ì‹¤íŒ¨: {e}")
        return {}


def is_ticker_active(ticker: str) -> bool:
    """íŠ¹ì • tickerê°€ ë§¤ë§¤ í™œì„±í™”ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸"""
    # .KS, .KQ ì œê±°í•˜ê³  ì²´í¬
    clean_ticker = ticker.replace(".KS", "").replace(".KQ", "")
    
    # TICKER_CONFIGì—ì„œ í™•ì¸
    if clean_ticker in TICKER_CONFIG:
        return TICKER_CONFIG[clean_ticker].get("active", True)
    
    # ì›ë³¸ tickerë¡œë„ í™•ì¸
    if ticker in TICKER_CONFIG:
        return TICKER_CONFIG[ticker].get("active", True)
    
    # ì„¤ì •ì— ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ True
    return True


def get_position_size_from_config(ticker: str, market: str) -> int:
    """
    Ticker_Infoì˜ ëª©í‘œë¹„ì¤‘ì— ë”°ë¼ íˆ¬ìê¸ˆì•¡ ê³„ì‚°
    ëª©í‘œë¹„ì¤‘ì´ ì—†ìœ¼ë©´ ê¸°ì¡´ calc_amount_proportional ë¡œì§ ì‚¬ìš©
    """
    clean_ticker = ticker.replace(".KS", "").replace(".KQ", "")
    
    config = TICKER_CONFIG.get(clean_ticker) or TICKER_CONFIG.get(ticker)
    
    if config and "target_weight" in config:
        target_weight = config["target_weight"]
        total_equity = calc_equity()
        
        # ëª©í‘œë¹„ì¤‘ * ì´ìì‚°
        target_amount = total_equity * target_weight
        
        # ë³€ë™ì„± íƒ€ê²ŸíŒ… ì ìš© (USë§Œ)
        target_amount *= vol_target_multiplier(market)
        
        # MIN/MAX ì œí•œ
        target_amount = max(MIN_TRADE_KRW, min(target_amount, MAX_TRADE_KRW))
        
        return int(target_amount)
    
    # ì„¤ì •ì— ì—†ìœ¼ë©´ ê¸°ë³¸ ë¡œì§ (soft_score ê¸°ë°˜)
    # ê¸°ë³¸ ì ìˆ˜ 85ë¡œ ê°€ì •
    return calc_amount_proportional(85.0, market)


def check_stop_loss_take_profit(ticker: str, current_price: float) -> dict:
    """
    í˜„ì¬ í¬ì§€ì…˜ì˜ ì†ìµë¥ ì„ ê³„ì‚°í•˜ì—¬ ì†ì ˆ/ìµì ˆ í•„ìš” ì—¬ë¶€ íŒë‹¨
    
    Returns:
        {
            "action": "HOLD" | "STOP_LOSS" | "TAKE_PROFIT",
            "pnl_pct": float,
            "reason": str
        }
    """
    if ticker not in PORTFOLIO:
        return {"action": "HOLD", "pnl_pct": 0, "reason": "No position"}
    
    pos = PORTFOLIO[ticker]
    avg_price = pos.get("avg_price", 0)
    
    if avg_price <= 0:
        return {"action": "HOLD", "pnl_pct": 0, "reason": "Invalid avg_price"}
    
    # ì†ìµë¥  ê³„ì‚°
    pnl_pct = (current_price - avg_price) / avg_price
    
    # Ticker_Infoì—ì„œ ì†ì ˆ/ìµì ˆ ê¸°ì¤€ ì½ê¸°
    clean_ticker = ticker.replace(".KS", "").replace(".KQ", "")
    config = TICKER_CONFIG.get(clean_ticker) or TICKER_CONFIG.get(ticker)
    
    if config:
        stop_loss = config.get("stop_loss", STOP_LOSS_PCT)
        take_profit = config.get("take_profit", TAKE_PROFIT_PCT)
    else:
        # ê¸°ë³¸ê°’ ì‚¬ìš©
        stop_loss = STOP_LOSS_PCT
        take_profit = TAKE_PROFIT_PCT
    
    # ì†ì ˆ ì²´í¬
    if pnl_pct <= stop_loss:
        return {
            "action": "STOP_LOSS",
            "pnl_pct": pnl_pct,
            "reason": f"ì†ì ˆ: {pnl_pct*100:.2f}% (ê¸°ì¤€: {stop_loss*100:.1f}%)"
        }
    
    # ìµì ˆ ì²´í¬
    if pnl_pct >= take_profit:
        return {
            "action": "TAKE_PROFIT",
            "pnl_pct": pnl_pct,
            "reason": f"ìµì ˆ: {pnl_pct*100:.2f}% (ê¸°ì¤€: {take_profit*100:.1f}%)"
        }
    
    return {"action": "HOLD", "pnl_pct": pnl_pct, "reason": "í™€ë”©"}


# ==============================================================================
# [5] ë§ˆì¼“ ì˜¤í”ˆ íŒì • (DST í¬í•¨)
# ==============================================================================
def is_kr_market_open(dt_kr=None) -> bool:
    dt_kr = dt_kr or now_kr()
    hm = dt_kr.hour * 100 + dt_kr.minute
    return 900 <= hm <= 1530

def is_us_market_open(dt_kr=None) -> bool:
    # ET ê¸°ì¤€ 09:30~16:00 (DST ìë™ ë°˜ì˜)
    dt_kr = dt_kr or now_kr()
    dt_et = dt_kr.astimezone(TZ_ET)
    h = dt_et.hour
    m = dt_et.minute
    # 09:30~16:00
    if (h > 9 and h < 16):
        return True
    if h == 9 and m >= 30:
        return True
    if h == 16 and m == 0:
        return True
    return False

# ==============================================================================
# [6] ë‰´ìŠ¤ + ë ˆì´ë”(ìŠ¤ìºë„ˆ)
# ==============================================================================
MASTER_KEYWORDS = [
    # ê³µí†µ
    "Earnings","Revenue","Profit","Guidance","Surprise","EPS",
    "Contract","Deal","Won","Acquisition","Merger","Buyback","Dividend",
    "Breakout","Squeeze","Volume","Halt","FDA","Approval","Offering","IPO",
    # KR
    "ì‹¤ì ","ë§¤ì¶œ","ì˜ì—…ì´ìµ","ìˆœì´ìµ","ê°€ì´ë˜ìŠ¤","ì„œí”„ë¼ì´ì¦ˆ","í‘ìì „í™˜",
    "ê³„ì•½","ìˆ˜ì£¼","ì²´ê²°","ì œíœ´","ìŠ¹ì¸","ì¸ìˆ˜","í•©ë³‘","ì§€ë¶„","ìì‚¬ì£¼","ì†Œê°","ë°°ë‹¹",
    "ê¸‰ë“±","ìƒí•œê°€","ì‹ ê³ ê°€","ëŒíŒŒ","í­ë“±","ì‡¼íŠ¸ìŠ¤í€´ì¦ˆ","ê±°ë˜ëŸ‰","VI",
    "íŠ¹ì§•ì£¼","ê³µì‹œ","ì •ì •","ìœ ìƒì¦ì","ê°ì","ì „í™˜ì‚¬ì±„","CB","BW"
]

def fetch_rss_titles(feeds):
    titles = []
    with concurrent.futures.ThreadPoolExecutor() as executor:
        fut_map = {executor.submit(feedparser.parse, url): url for url in feeds}
        for fut in concurrent.futures.as_completed(fut_map):
            try:
                feed = fut.result()
                for entry in getattr(feed, "entries", [])[:120]:
                    link = getattr(entry, "link", "")
                    title = getattr(entry, "title", "")
                    if not title:
                        continue
                    if link and link in SEEN_LINKS:
                        continue
                    if any(kw.lower() in title.lower() for kw in MASTER_KEYWORDS):
                        titles.append(title.strip())
                        if link:
                            SEEN_LINKS[link] = int(time.time())
            except Exception as e:
                print(f"âš ï¸ RSS íŒŒì‹± ì—ëŸ¬: {e}")
    return titles[:200]

def fetch_news_24h():
    # KR/US ë‘˜ ë‹¤ í•­ìƒ ìˆ˜ì§‘
    kr_feeds = [
        "https://rss.hankyung.com/feed/market.xml",
        # í•„ìš” ì‹œ ì—¬ê¸°ì— KR RSS ì¶”ê°€
    ]
    us_feeds = [
        "http://feeds.marketwatch.com/marketwatch/topstories/",
        "http://feeds.reuters.com/reuters/businessNews",
        # í•„ìš” ì‹œ ì—¬ê¸°ì— US RSS ì¶”ê°€
    ]
    prune_seen_links()
    kr_titles = fetch_rss_titles(kr_feeds)
    us_titles = fetch_rss_titles(us_feeds)
    return kr_titles, us_titles

# ---------------------------
# KR ë ˆì´ë”: ë„¤ì´ë²„ ê¸ˆìœµ "ê±°ë˜ìƒìœ„/ê¸‰ë“±/ê¸‰ë½"ì—ì„œ í›„ë³´ ìˆ˜ì§‘
# ---------------------------
def scan_kr_radar():
    candidates = set()
    urls = [
        # ê±°ë˜ëŸ‰ ìƒìœ„
        "https://finance.naver.com/sise/sise_quant.naver",
        # ìƒìŠ¹ë¥  ìƒìœ„
        "https://finance.naver.com/sise/sise_rise.naver",
        # í•˜ë½ë¥  ìƒìœ„
        "https://finance.naver.com/sise/sise_fall.naver",
    ]
    for url in urls:
        try:
            html = requests.get(url, timeout=10, headers={"User-Agent": "Mozilla/5.0"}).text
            dfs = pd.read_html(StringIO(html))
            if not dfs:
                continue
            df = dfs[1] if len(dfs) > 1 else dfs[0]
            # ì¢…ëª©ëª… ì»¬ëŸ¼ì—ì„œ ë§í¬ì— code= ì¶”ì¶œ
            codes = re.findall(r"code=(\d{6})", html)
            # ë„ˆë¬´ ë§ìœ¼ë©´ ìƒìœ„ë§Œ
            for c in codes[:60]:
                candidates.add(c)
        except Exception as e:
            print(f"âš ï¸ KR ë ˆì´ë” ì‹¤íŒ¨({url}): {e}")
    return list(candidates)[:80]

# ---------------------------
# US ë ˆì´ë”: Yahoo Screener JSON (most_actives / day_gainers / day_losers)
# ---------------------------
def yahoo_screener(scr_id="most_actives", count=80):
    url = "https://query1.finance.yahoo.com/v1/finance/screener/predefined/saved"
    try:
        r = requests.get(url, params={"scrIds": scr_id, "count": count, "start": 0}, timeout=10,
                         headers={"User-Agent": "Mozilla/5.0"})
        js = r.json()
        quotes = js.get("finance", {}).get("result", [{}])[0].get("quotes", [])
        out = []
        for q in quotes:
            sym = q.get("symbol")
            if sym and isinstance(sym, str) and sym.isascii():
                out.append(sym.upper())
        return out[:count]
    except Exception as e:
        print(f"âš ï¸ US ë ˆì´ë” ì‹¤íŒ¨({scr_id}): {e}")
        return []

def scan_us_radar():
    cand = set()
    for sid in ["most_actives", "day_gainers", "day_losers"]:
        for s in yahoo_screener(sid, 80):
            cand.add(s)
    return list(cand)[:150]

# ==============================================================================
# [7] AI ë¶„ì„ (KR / US ë¶„ë¦¬)
# ==============================================================================
def analyze_with_ai(market: str, news_titles: list, radar_tickers: list):
    if not model:
        return []
    # ì…ë ¥ì´ ë„ˆë¬´ ê¸¸ì–´ì§€ë©´ ì„±ëŠ¥/ë¹„ìš©/ì‹œê°„ ë‹¤ ê¹¨ì§ -> ìƒí•œ
    news_titles = news_titles[:60]
    radar_tickers = radar_tickers[:120]

    prompt = f"""
ì—­í• : ë‹¹ì‹ ì€ ì „ë¬¸ í€€íŠ¸ íŠ¸ë ˆì´ë”ë‹¤.
ì‹œì¥: {market}

[ì…ë ¥]
1) ë‰´ìŠ¤ í—¤ë“œë¼ì¸(ì¤‘ìš” í‚¤ì›Œë“œë§Œ ê±¸ëŸ¬ì§„ ë¦¬ìŠ¤íŠ¸)
2) ë ˆì´ë” í‹°ì»¤(ë‰´ìŠ¤ê°€ ì—†ì–´ë„ ì˜¤ëŠ˜ ê±°ë˜ê°€ íŠ€ëŠ” ì¢…ëª© í›„ë³´)

[ëª©í‘œ]
- ë‹¨ê¸°(ìŠ¤ìº˜í”„/ìŠ¤ìœ™) ê´€ì ì—ì„œ "í™•ë¥ ì´ ë†’ì€" í›„ë³´ 5ê°œ ì´í•˜ë¥¼ ê³ ë¥´ê³ ,
- ê°ê°ì— ëŒ€í•´ ì ìˆ˜/ì´ìœ /ê±°ë˜ìŠ¤íƒ€ì¼ì„ ì œì‹œí•´ë¼.
- ë‰´ìŠ¤ê°€ ì—†ê³  ë ˆì´ë”ë¡œë§Œ ì¡íŒ ì¢…ëª©ë„ ê°€ëŠ¥í•˜ë‚˜, ê·¸ ê²½ìš° "ë ˆì´ë‹¤í›„ë³´"ë¼ê³  ëª…ì‹œ.

[ê·œì¹™]
- ì¶œë ¥ì€ JSON ë¦¬ìŠ¤íŠ¸ë§Œ.
- reasonì€ ë°˜ë“œì‹œ í•œê¸€.
- marketì€ "KR" ë˜ëŠ” "US"ë¥¼ ê·¸ëŒ€ë¡œ ë„£ì–´ë¼.
- KR í‹°ì»¤ëŠ” 6ìë¦¬ ì½”ë“œ(ì˜ˆ: 005930) ë˜ëŠ” ì¢…ëª©ëª….
- US í‹°ì»¤ëŠ” ì˜ˆ: NVDA, TSLA.
- score 0~100 (80 ì´ìƒë§Œ ì§„ì… í›„ë³´ë¡œ ì¶”ì²œ)
- trade_type: "SCALP" ë˜ëŠ” "SWING"

[ì¶œë ¥ ì˜ˆì‹œ]
[
  {{"market":"KR","ticker":"005930","score":88,"trade_type":"SWING","reason":"..."}},
  {{"market":"US","ticker":"NVDA","score":92,"trade_type":"SWING","reason":"..."}}
]

[ë‰´ìŠ¤]
{json.dumps(news_titles, ensure_ascii=False)}

[ë ˆì´ë” í‹°ì»¤]
{json.dumps(radar_tickers, ensure_ascii=False)}
"""
    try:
        res = model.generate_content(prompt)
        text = res.text.replace("```json", "").replace("```", "").strip()
        m = re.search(r"\[.*\]", text, re.DOTALL)
        if not m:
            print("âš ï¸ AI ì‘ë‹µì—ì„œ JSON ë¦¬ìŠ¤íŠ¸ë¥¼ ì°¾ì§€ ëª»í•¨")
            return []
        arr = json.loads(m.group())
        if not isinstance(arr, list):
            return []
        return arr
    except Exception as e:
        print(f"âš ï¸ analyze_with_ai ì—ëŸ¬: {e}")
        return []

# ==============================================================================
# [8] KIS: í† í°/í•´ì‹œí‚¤/ì‹œì„¸/ì£¼ë¬¸ (KR+US)
# ==============================================================================
def kis_token():
    global ACCESS_TOKEN, ACCESS_TOKEN_EXPIRES_AT
    # í† í° ìºì‹œ
    if ACCESS_TOKEN and time.time() < ACCESS_TOKEN_EXPIRES_AT - 30:
        return ACCESS_TOKEN

    try:
        url = f"{kis_domain()}/oauth2/tokenP"
        r = requests.post(url, json={
            "grant_type": "client_credentials",
            "appkey": KIS_APP_KEY,
            "appsecret": KIS_APP_SECRET
        }, timeout=8)
        js = r.json()
        ACCESS_TOKEN = js.get("access_token", "")
        expires_in = safe_int(js.get("expires_in"), 1800)
        ACCESS_TOKEN_EXPIRES_AT = int(time.time()) + expires_in
        return ACCESS_TOKEN
    except Exception as e:
        print(f"âš ï¸ kis_token ì—ëŸ¬: {e}")
        return ""

def kis_hashkey(token: str, body: dict) -> str:
    try:
        url = f"{kis_domain()}/uapi/hashkey"
        headers = {
            "content-type": "application/json",
            "authorization": f"Bearer {token}",
            "appKey": KIS_APP_KEY,
            "appSecret": KIS_APP_SECRET,
        }
        r = requests.post(url, headers=headers, data=json.dumps(body), timeout=8)
        js = r.json()
        return js.get("HASH", "") or js.get("hash", "")
    except Exception as e:
        print(f"âš ï¸ kis_hashkey ì—ëŸ¬: {e}")
        return ""

# --------------------------
# KIS êµ­ë‚´ í˜„ì¬ê°€
# --------------------------
def kis_price_kr(code6: str):
    try:
        token = kis_token()
        if not token:
            return None
        url = f"{kis_domain()}/uapi/domestic-stock/v1/quotations/inquire-price"
        headers = {
            "content-type": "application/json",
            "authorization": f"Bearer {token}",
            "appKey": KIS_APP_KEY,
            "appSecret": KIS_APP_SECRET,
            "tr_id": "FHKST01010100",  # êµ­ë‚´ í˜„ì¬ê°€
        }
        params = {
            "FID_COND_MRKT_DIV_CODE": "J",
            "FID_INPUT_ISCD": code6
        }
        r = requests.get(url, headers=headers, params=params, timeout=8)
        js = r.json()
        out = js.get("output", {})
        price = safe_float(out.get("stck_prpr"))
        return price
    except Exception as e:
        print(f"âš ï¸ kis_price_kr ì—ëŸ¬: {e}")
        return None

# --------------------------
# KIS í•´ì™¸ í˜„ì¬ê°€ (EXCD, SYMB)
# - ì˜ˆì‹œ: EXCD=NASD, SYMB=AAPL
# --------------------------
def kis_price_us(symbol: str, exch: str):
    try:
        token = kis_token()
        if not token:
            return None
        url = f"{kis_domain()}/uapi/overseas-price/v1/quotations/price"
        headers = {
            "content-type": "application/json",
            "authorization": f"Bearer {token}",
            "appKey": KIS_APP_KEY,
            "appSecret": KIS_APP_SECRET,
            "tr_id": "HHDFS00000300",  # í•´ì™¸ í˜„ì¬ê°€  [oai_citation:1â€¡Glama â€“ MCP Hosting Platform](https://glama.ai/mcp/servers/%40migusdn/KIS_MCP_Server/blob/090021d7c863b24ce37cb029e563b1ec7e42a5c4/server.py)
        }
        params = {
            "AUTH": "",
            "EXCD": exch,
            "SYMB": symbol
        }
        r = requests.get(url, headers=headers, params=params, timeout=8)
        js = r.json()
        out = js.get("output", {})
        # KIS í•´ì™¸í˜„ì¬ê°€ í•„ë“œê°€ ì¼€ì´ìŠ¤ë§ˆë‹¤ ë‹¤ë¥¼ ìˆ˜ ìˆì–´ í›„ë³´ ë‹¤ íƒìƒ‰
        for k in ["last", "last_price", "ovrs_nmix_prpr", "stck_prpr", "prpr"]:
            p = safe_float(out.get(k))
            if p:
                return p
        # ê·¸ë˜ë„ ì—†ìœ¼ë©´ output2 ë“±ë„ íƒìƒ‰
        out2 = js.get("output2", {})
        for k in ["last", "ovrs_nmix_prpr", "prpr"]:
            p = safe_float(out2.get(k))
            if p:
                return p
        return None
    except Exception as e:
        print(f"âš ï¸ kis_price_us ì—ëŸ¬: {e}")
        return None

# --------------------------
# KIS ì£¼ë¬¸ (êµ­ë‚´)
# --------------------------
def kis_order_kr(code6: str, qty: int, price: float, side: str):
    if DRY_RUN:
        return True, "DRY_RUN"

    token = kis_token()
    if not token:
        return False, "NO_TOKEN"

    # tr_id (ëª¨ì˜/ì‹¤ì „ ì°¨ì´)
    # êµ­ë‚´ì£¼ì‹ í˜„ê¸ˆë§¤ìˆ˜/ë§¤ë„ëŠ” ê¸°ì¡´ ì½”ë“œ ê¸°ë°˜ ìœ ì§€:
    # - ì‹¤ì „: TTTC0802U / TTTC0801U
    # - ëª¨ì˜: VTTC0802U / VTTC0801U (í™˜ê²½ì— ë”°ë¼ ë‹¤ë¥¼ ìˆ˜ ìˆì–´ ì‹¤íŒ¨ ì‹œ ë¡œê·¸ë¡œ í™•ì¸)
    if KIS_ENV == "VIRTUAL":
        tr_id = "VTTC0802U" if side == "BUY" else "VTTC0801U"
    else:
        tr_id = "TTTC0802U" if side == "BUY" else "TTTC0801U"

    url = f"{kis_domain()}/uapi/domestic-stock/v1/trading/order-cash"
    body = {
        "CANO": KIS_CANO,
        "ACNT_PRDT_CD": KIS_ACNT_PRDT_CD,
        "PDNO": code6,
        "ORD_DVSN": "01" if price == 0 else "00",
        "ORD_QTY": str(qty),
        "ORD_UNPR": str(int(price)) if price else "0",
    }

    hk = kis_hashkey(token, body)
    headers = {
        "content-type": "application/json",
        "authorization": f"Bearer {token}",
        "appKey": KIS_APP_KEY,
        "appSecret": KIS_APP_SECRET,
        "tr_id": tr_id,
        "custtype": "P",
    }
    if hk:
        headers["hashkey"] = hk

    try:
        r = requests.post(url, headers=headers, data=json.dumps(body), timeout=10)
        js = r.json()
        ok = (js.get("rt_cd") == "0")
        return ok, js.get("msg1", "")
    except Exception as e:
        return False, str(e)

# --------------------------
# KIS ì£¼ë¬¸ (í•´ì™¸ì£¼ì‹) - USê¹Œì§€ ìë™ë§¤ë§¤ í™•ì¥
# - í•´ì™¸ ì£¼ë¬¸ ë°”ë””/í•„ë“œ: OVRS_EXCG_CD, PDNO, OVRS_ORD_UNPR, ORD_DVSN ë“±  [oai_citation:2â€¡Glama â€“ MCP Hosting Platform](https://glama.ai/mcp/servers/%40migusdn/KIS_MCP_Server/blob/090021d7c863b24ce37cb029e563b1ec7e42a5c4/server.py)
# --------------------------
def kis_order_us(symbol: str, exch: str, qty: int, price: float, side: str):
    if DRY_RUN:
        return True, "DRY_RUN"

    token = kis_token()
    if not token:
        return False, "NO_TOKEN"

    # í•´ì™¸ TR_ID (ëª¨ì˜/ì‹¤ì „)
    # - ì‹¤ì „ BUY: TTTT1002U / SELL: TTTT1006U
    # - ëª¨ì˜ BUY: VTTT1002U / SELL: VTTT1001U (ì°¸ì¡° êµ¬í˜„)  [oai_citation:3â€¡Glama â€“ MCP Hosting Platform](https://glama.ai/mcp/servers/%40migusdn/KIS_MCP_Server/blob/090021d7c863b24ce37cb029e563b1ec7e42a5c4/server.py)
    if KIS_ENV == "VIRTUAL":
        tr_id = "VTTT1002U" if side == "BUY" else "VTTT1001U"
    else:
        tr_id = "TTTT1002U" if side == "BUY" else "TTTT1006U"

    url = f"{kis_domain()}/uapi/overseas-stock/v1/trading/order"
    body = {
        "CANO": KIS_CANO,
        "ACNT_PRDT_CD": KIS_ACNT_PRDT_CD,
        "OVRS_EXCG_CD": exch,     # NASD / NYSE / AMEX ...  [oai_citation:4â€¡Glama â€“ MCP Hosting Platform](https://glama.ai/mcp/servers/%40migusdn/KIS_MCP_Server/blob/090021d7c863b24ce37cb029e563b1ec7e42a5c4/server.py)
        "PDNO": symbol,           # AAPL ...  [oai_citation:5â€¡Glama â€“ MCP Hosting Platform](https://glama.ai/mcp/servers/%40migusdn/KIS_MCP_Server/blob/090021d7c863b24ce37cb029e563b1ec7e42a5c4/server.py)
        "ORD_QTY": str(qty),
        "OVRS_ORD_UNPR": str(round(price, 2)) if price else "0",
        "ORD_SVR_DVSN_CD": "0",
        "ORD_DVSN": "00" if price and price > 0 else "01"  # 00 ì§€ì •ê°€ / 01 ì‹œì¥ê°€  [oai_citation:6â€¡Glama â€“ MCP Hosting Platform](https://glama.ai/mcp/servers/%40migusdn/KIS_MCP_Server/blob/090021d7c863b24ce37cb029e563b1ec7e42a5c4/server.py)
    }

    hk = kis_hashkey(token, body)
    headers = {
        "content-type": "application/json",
        "authorization": f"Bearer {token}",
        "appKey": KIS_APP_KEY,
        "appSecret": KIS_APP_SECRET,
        "tr_id": tr_id,
    }
    if hk:
        headers["hashkey"] = hk

    try:
        r = requests.post(url, headers=headers, data=json.dumps(body), timeout=12)
        js = r.json()
        ok = (js.get("rt_cd") == "0")
        return ok, js.get("msg1", "")
    except Exception as e:
        return False, str(e)

# ==============================================================================
# [9] ê°€ê²©: YF(ë¶„ì„) + KIS(ì£¼ë¬¸ì§ì „) êµì°¨ê²€ì¦
# ==============================================================================
def yf_price(market: str, ticker: str):
    try:
        if market == "KR":
            sym = normalize_kr_symbol(ticker)
            if not sym:
                return None
        else:
            sym = ticker.upper()
        info = yf.Ticker(sym).fast_info
        return safe_float(info.get("last_price"))
    except:
        return None

def infer_us_exchange_code(ticker: str):
    # yfinance exchange ì½”ë“œ -> KIS EXCDë¡œ ê·¼ì‚¬ ë§¤í•‘
    # NMS(ë‚˜ìŠ¤ë‹¥), NYQ(ë‰´ìš•), ASE(ì•„ë©•ìŠ¤)
    try:
        inf = yf.Ticker(ticker.upper()).fast_info
        exch = (inf.get("exchange") or "").upper()
        if "NMS" in exch or "NAS" in exch:
            return "NASD"
        if "NYQ" in exch or "NYS" in exch:
            return "NYSE"
        if "ASE" in exch or "AMEX" in exch:
            return "AMEX"
    except:
        pass
    return "NASD"

def get_price_hybrid(market: str, ticker: str, exch: str = None):
    """
    return: (price_for_trade, yf_p, kis_p, gap)
    """
    yf_p = yf_price(market, ticker)
    kis_p = None
    if market == "KR":
        if re.fullmatch(r"\d{6}", ticker):
            kis_p = kis_price_kr(ticker)
    else:
        exch = exch or infer_us_exchange_code(ticker)
        kis_p = kis_price_us(ticker.upper(), exch)

    # KISê°€ ì—†ìœ¼ë©´ YF ì‚¬ìš©
    if not kis_p or not yf_p:
        return (kis_p or yf_p), yf_p, kis_p, None

    gap = abs(kis_p - yf_p) / yf_p if yf_p else None

    # í•˜ë“œ ê°€ë“œ: ê´´ë¦¬ ë„ˆë¬´ í¬ë©´ ê±°ë˜ ìŠ¤í‚µ(ìƒí™© ì´ìƒ/ë°ì´í„° ì´ìƒ)
    if gap and gap >= LATENCY_GUARD_HARD:
        return None, yf_p, kis_p, gap

    # ì†Œí”„íŠ¸ ê°€ë“œ: KISê°€ë¡œ êµì²´
    if gap and gap >= LATENCY_GUARD_SOFT:
        return kis_p, yf_p, kis_p, gap

    # ê´´ë¦¬ ì‘ìœ¼ë©´ YF ê·¸ëŒ€ë¡œ ì¨ë„ ë˜ì§€ë§Œ, ì‹¤ì œ ì²´ê²°ì€ KISê°€ê°€ ë” ì•ˆì „
    return kis_p, yf_p, kis_p, gap

# ==============================================================================
# [10] ê¸°ìˆ  ë¶„ì„ (ê¸°ì¡´ SMC/OB+RSI ê¸°ë°˜ ìœ ì§€)
# ==============================================================================
def analyze_technicals(market: str, ticker: str):
    """
    1ê°œì›” 60ë¶„ë´‰, OB + RSI + ê±°ë˜ëŒ€ê¸ˆ í•„í„°
    """
    try:
        if market == "KR":
            sym = normalize_kr_symbol(ticker)
            if not sym:
                return None
        else:
            sym = ticker.upper()

        df = yf.Ticker(sym).history(period="1mo", interval="60m", prepost=True)
        if df is None or df.empty or len(df) < 30:
            return None

        curr_price = float(df["Close"].iloc[-1])
        avg_vol = df["Volume"][-5:].mean()
        notional = curr_price * avg_vol * (EXCHANGE_RATE if market == "US" else 1)

        if notional < MIN_VOLUME_KRW:
            return None

        # OB íƒìƒ‰(ë‹¨ìˆœ)
        ob_found = False
        ob_range = (0.0, 0.0)
        for i in range(len(df) - 2, max(len(df) - 30, 5), -1):
            prev = df.iloc[i - 1]
            curr = df.iloc[i]
            if (curr["Close"] - prev["Close"]) / prev["Close"] > 0.02 and prev["Close"] < prev["Open"]:
                ob_found = True
                ob_range = (float(prev["Low"]), float(prev["High"]))
                break

        # RSI
        delta = df["Close"].diff()
        up = delta.clip(lower=0)
        down = -1 * delta.clip(upper=0)
        ema_up = up.ewm(com=13, adjust=False).mean()
        ema_down = down.ewm(com=13, adjust=False).mean()
        rs = ema_up / ema_down
        rsi = float(100 - (100 / (1 + rs.iloc[-1])))

        in_ob = ob_found and (ob_range[0] <= curr_price <= ob_range[1])

        return {"price": curr_price, "rsi": rsi, "ob": ob_found, "in_ob": in_ob}
    except Exception as e:
        print(f"âš ï¸ analyze_technicals ì—ëŸ¬: {e}")
        return None

# ==============================================================================
# [11] ìì‚°/ë¹„ì¤‘ ê³„ì‚°
# ==============================================================================
def calc_equity():
    eq = VIRTUAL_CASH_KRW
    for t, info in PORTFOLIO.items():
        m = info.get("market")
        exch = info.get("exch")
        px, _, _, _ = get_price_hybrid(m, t, exch)
        if px:
            rate = EXCHANGE_RATE if m == "US" else 1
            eq += px * info["qty"] * rate
    return eq

def calc_dynamic_amount(score: float):
    base = calc_equity() * EQUITY_RATIO_PER_TRADE if USE_EQUITY_RATIO else INVEST_PER_TRADE_KRW
    if score >= 90:
        mult = 2.0
    elif score >= 85:
        mult = 1.5
    else:
        mult = 1.0
    amt = base * mult
    amt = max(amt, MIN_TRADE_KRW)
    amt = min(amt, MAX_TRADE_KRW)
    eq = calc_equity()
    amt = min(amt, eq * MAX_TRADE_PCT, VIRTUAL_CASH_KRW)
    return int(amt)

# ==============================================================================
# [12] ì£¼ë¬¸ ì‹¤í–‰(ë¶„í• ë§¤ìˆ˜/ë§¤ë„) + ë¡œê·¸/ìƒíƒœ ì €ì¥
# ==============================================================================
def place_order_scaled(market: str, ticker: str, side: str, price: float, exch=None,
                       strategy="", reason="", base_amount=None, trade_type="DEFAULT"):
    global VIRTUAL_CASH_KRW, TODAY_PROFIT_KRW, PORTFOLIO, DAILY_TRADE_COUNT

    ts = now_kr().strftime("%Y-%m-%d %H:%M:%S")
    rate = EXCHANGE_RATE if market == "US" else 1

    if side == "BUY":
        if DAILY_TRADE_COUNT.get(f"{market}:{ticker}", 0) >= MAX_RETRIES_PER_DAY:
            return

        p = PORTFOLIO.get(
            ticker,
            {"step": 0, "qty": 0, "avg_price": 0.0, "half_sold": False, "market": market, "trade_type": trade_type, "exch": exch}
        )
        if p["step"] >= len(SCALING_BUY_STEPS):
            return

        if base_amount is None:
            base_amount = calc_dynamic_amount(85)

        alloc_krw = base_amount * SCALING_BUY_STEPS[p["step"]]
        qty = int(alloc_krw / (price * rate))
        if qty <= 0:
            return

        cost = qty * price * rate
        if cost > VIRTUAL_CASH_KRW:
            qty = int(VIRTUAL_CASH_KRW / (price * rate))
            cost = qty * price * rate
            if qty <= 0:
                return

        # ì£¼ë¬¸
        if market == "KR":
            ok, msg = kis_order_kr(ticker, qty, price, "BUY")
        else:
            exch = exch or infer_us_exchange_code(ticker)
            ok, msg = kis_order_us(ticker.upper(), exch, qty, price, "BUY")

        if not ok:
            send_telegram(f"âŒ [ì£¼ë¬¸ì‹¤íŒ¨][{market}] {ticker} BUY / {msg}")
            return

        # í¬íŠ¸í´ë¦¬ì˜¤ ê°±ì‹ 
        if p["qty"] + qty > 0:
            p["avg_price"] = ((p["qty"] * p["avg_price"]) + (qty * price)) / (p["qty"] + qty)
        p["qty"] += qty
        p["step"] += 1
        p["market"] = market
        p["trade_type"] = trade_type
        p["exch"] = exch
        PORTFOLIO[ticker] = p

        VIRTUAL_CASH_KRW -= cost
        DAILY_TRADE_COUNT[f"{market}:{ticker}"] = DAILY_TRADE_COUNT.get(f"{market}:{ticker}", 0) + 1

        log_trade_to_sheet(ts, ticker, market, exch, "BUY", price, qty, 0, f"{strategy}({p['step']}ì°¨)", note=msg)
        send_telegram(f"ğŸš€ [ë§¤ìˆ˜][{market}] {ticker} {p['step']}ì°¨\nê°€ê²©: {price}\nê¸ˆì•¡: {int(cost):,}ì›\nì‚¬ìœ : {reason}\nëª¨ë“œ: KIS_ENV={KIS_ENV}, DRY_RUN={DRY_RUN}")

        save_state()

    elif side == "SELL":
        if ticker not in PORTFOLIO:
            return
        p = PORTFOLIO[ticker]
        exch = p.get("exch")

        sell_qty = p["qty"]
        if strategy == "ìµì ˆ_1ì°¨" and not p.get("half_sold", False):
            sell_qty = int(p["qty"] * SCALING_SELL_STEPS[0])
            p["half_sold"] = True

        if sell_qty <= 0:
            return

        pnl = (price - p["avg_price"]) * sell_qty * rate

        if market == "KR":
            ok, msg = kis_order_kr(ticker, sell_qty, price, "SELL")
        else:
            exch = exch or infer_us_exchange_code(ticker)
            ok, msg = kis_order_us(ticker.upper(), exch, sell_qty, price, "SELL")

        if not ok:
            send_telegram(f"âŒ [ì£¼ë¬¸ì‹¤íŒ¨][{market}] {ticker} SELL / {msg}")
            return

        TODAY_PROFIT_KRW += pnl
        VIRTUAL_CASH_KRW += sell_qty * price * rate

        log_trade_to_sheet(ts, ticker, market, exch, "SELL", price, sell_qty, int(pnl), strategy, note=msg)
        send_telegram(f"ğŸ’° [ë§¤ë„][{market}] {ticker} ({strategy})\nìˆ˜ìµ: {int(pnl):,}ì›\nëª¨ë“œ: KIS_ENV={KIS_ENV}, DRY_RUN={DRY_RUN}")

        if sell_qty >= p["qty"]:
            del PORTFOLIO[ticker]
        else:
            p["qty"] -= sell_qty
            PORTFOLIO[ticker] = p

        save_state()

# ==============================================================================
# [13] í¬ì§€ì…˜ ê´€ë¦¬ (ì†ì ˆ/ìµì ˆ)
# ==============================================================================
def manage_positions_cycle():
    for ticker, info in list(PORTFOLIO.items()):
        m = info.get("market")
        exch = info.get("exch")
        px, yf_p, kis_p, gap = get_price_hybrid(m, ticker, exch)
        if not px:
            obs_drop("MANAGE_PX_NONE", m, ticker, None)
            continue

        pnl_pct = (px - info["avg_price"]) / info["avg_price"]

        # (ì±… ë°˜ì˜) Two-threshold stop-loss
        # 1ì°¨: -5% -> ì ˆë°˜ ì²­ì‚°
        if pnl_pct <= -0.05 and not info.get("half_sold", False):
            obs_inc("STOPLOSS_HALF")
            place_order_scaled(m, ticker, "SELL", px, exch=exch, strategy="ì†ì ˆ_1ì°¨(ì ˆë°˜)")
            continue

        # 2ì°¨: -10% -> ì „ëŸ‰ ì²­ì‚°
        if pnl_pct <= -0.10:
            obs_inc("STOPLOSS_ALL")
            place_order_scaled(m, ticker, "SELL", px, exch=exch, strategy="ì†ì ˆ_2ì°¨(ì „ëŸ‰)")
            continue

        # ìµì ˆ: 15% ì „ëŸ‰(ê¸°ì¡´ ìœ ì§€)
        if pnl_pct >= TAKE_PROFIT_PCT:
            obs_inc("TAKEPROFIT_ALL")
            place_order_scaled(m, ticker, "SELL", px, exch=exch, strategy="ìµì ˆ_ì™„ë£Œ")

# ==============================================================================
# [14] ë©”ì¸ ì—”ì§„: 24ì‹œê°„ ìˆ˜ì§‘ + ì¥ ì—´ë¦¬ë©´ ì‹¤í–‰
# ==============================================================================
def daily_reset_if_needed():
    global LAST_RESET_DATE, TODAY_PROFIT_KRW, DAILY_TRADE_COUNT
    today = datetime.date.today()
    if LAST_RESET_DATE != today:
        LAST_RESET_DATE = today
        TODAY_PROFIT_KRW = 0
        DAILY_TRADE_COUNT = {}
        print(f"ğŸ”„ [{today}] ì¼ì¼ ë¦¬ì…‹ ì™„ë£Œ")
        save_state()

def update_fx():
    global EXCHANGE_RATE
    try:
        today = datetime.date.today()
        df_fx = fdr.DataReader("USD/KRW", today - datetime.timedelta(days=10))
        EXCHANGE_RATE = float(df_fx["Close"].iloc[-1])
    except Exception as e:
        print(f"âš ï¸ í™˜ìœ¨ ì¡°íšŒ ì‹¤íŒ¨: {e}")

def normalize_signal_market_and_ticker(sig):
    market = str(sig.get("market", "")).strip().upper()
    ticker = str(sig.get("ticker", "")).strip()
    score = safe_float(sig.get("score"), 0)
    reason = str(sig.get("reason", "ì‚¬ìœ  ì—†ìŒ")).strip()
    ttype = str(sig.get("trade_type", "SWING")).strip().upper()
    if ttype not in ["SCALP", "SWING"]:
        ttype = "SWING"

    if market == "KR":
        # ì¢…ëª©ëª… -> ì½”ë“œë¡œ ì •ê·œí™”
        if re.fullmatch(r"\d{6}", ticker):
            code6 = ticker
        else:
            sym = normalize_kr_symbol(ticker)
            if not sym:
                return None
            code6 = sym.split(".")[0]
        return {"market": "KR", "ticker": code6, "score": score, "reason": reason, "trade_type": ttype, "exch": None}

    if market == "US":
        tkr = ticker.upper()
        exch = infer_us_exchange_code(tkr)
        return {"market": "US", "ticker": tkr, "score": score, "reason": reason, "trade_type": ttype, "exch": exch}

    return None

def enqueue_signal_if_market_closed(sig_norm):
    # ì‹œì¥ ë‹«í˜€ë„ 80+ë©´ ì ì¬
    if sig_norm["score"] < 80:
        return
    PENDING_SIGNALS.append({
        "ts": now_kr().strftime("%Y-%m-%d %H:%M:%S"),
        **sig_norm
    })

def pop_pending_for_market(market: str, max_n=10):
    # 12ì‹œê°„ ì§€ë‚œ ê±´ ë²„ë¦¼
    fresh = []
    out = []
    cutoff = now_kr() - datetime.timedelta(hours=12)
    for s in PENDING_SIGNALS:
        try:
            ts = datetime.datetime.strptime(s["ts"], "%Y-%m-%d %H:%M:%S").replace(tzinfo=TZ_KR)
        except:
            ts = now_kr()
        if ts < cutoff:
            continue
        if s.get("market") == market and len(out) < max_n:
            out.append(s)
        else:
            fresh.append(s)
    # ë‚¨ì€ ê²ƒ(ë‹¤ë¥¸ ì‹œì¥/ì•„ì§ ë‚¨ì€ ê²ƒ)ì€ ìœ ì§€
    # out ì œì™¸í•œ fresh + (outì—ì„œ max_n ì´ˆê³¼ë¶„ì€ freshë¡œ ë‚¨ê²¨ì•¼ í•˜ëŠ”ë° ì—¬ê¸°ì„  out ì œí•œë§Œ)
    PENDING_SIGNALS[:] = fresh
    return out

def main_engine_cycle():
    sheet_heartbeat()
    daily_reset_if_needed()
    sheet_heartbeat()
    update_fx()

    dt = now_kr()
    kr_open = is_kr_market_open(dt)
    us_open = is_us_market_open(dt)

    print(f"ğŸ•’ {dt.strftime('%Y-%m-%d %H:%M')} | KR_OPEN={kr_open} US_OPEN={us_open} | í˜„ê¸ˆ:{int(VIRTUAL_CASH_KRW):,} ì†ìµ:{int(TODAY_PROFIT_KRW):,} ë³´ìœ :{len(PORTFOLIO)} Pending:{len(PENDING_SIGNALS)}")

    # 24ì‹œê°„: ë‰´ìŠ¤ + ë ˆì´ë” ìˆ˜ì§‘
    kr_news, us_news = fetch_news_24h()
    kr_radar = scan_kr_radar()
    us_radar = scan_us_radar()
    print(f"[NEWS] KR={len(kr_news)} US={len(us_news)}")
    print(f"[RADAR] KR={len(kr_radar)} US={len(us_radar)}")

    # AI ë¶„ì„(ì¥ ìƒê´€ì—†ì´ ìˆ˜í–‰)
    kr_sigs = analyze_with_ai("KR", kr_news, kr_radar) if (kr_news or kr_radar) else []
    us_sigs = analyze_with_ai("US", us_news, us_radar) if (us_news or us_radar) else []
    print(f"[AI_SIGS] KR={len(kr_sigs)} US={len(us_sigs)}")

    # ê¸°ë¡ + ì ì¬
    for sig in (kr_sigs + us_sigs):
        if not isinstance(sig, dict):
            continue
        norm = normalize_signal_market_and_ticker(sig)
        if not norm:
            continue

        # ì¥ ë‹«í˜€ë„ ê¸°ë¡ì€ ë‚¨ê¹€
        log_ai_thought(norm["market"], norm["ticker"], norm["score"],
                       "SCAN" if ((norm["market"] == "KR" and kr_open) or (norm["market"] == "US" and us_open)) else "PRE-SCAN",
                       norm["trade_type"], norm["reason"],
                       source="NEWS+RADAR")

        # ì¥ ë‹«í˜€ìˆìœ¼ë©´ Pending ì ì¬
        if norm["market"] == "KR" and not kr_open:
            enqueue_signal_if_market_closed(norm)
        if norm["market"] == "US" and not us_open:
            enqueue_signal_if_market_closed(norm)

    save_state()

    # ì†ì‹¤ í•œë„ë©´ ì‹ ê·œë§¤ìˆ˜ ì¤‘ì§€(ì²­ì‚°/ê´€ë¦¬ë§Œ)
    if TODAY_PROFIT_KRW <= MAX_DAILY_LOSS_KRW:
        print("ğŸš¨ ì¼ì¼ ì†ì‹¤ í•œë„ ì´ˆê³¼ â†’ ì‹ ê·œ ë§¤ìˆ˜ ì¤‘ì§€(ê´€ë¦¬ë§Œ)")
        return

    # ì‹œì¥ ì—´ë¦¬ë©´ Pending ë¨¼ì € ì²˜ë¦¬ + ì´ë²ˆ ì‚¬ì´í´ ì‹œê·¸ë„ë„ ì²˜ë¦¬
    if kr_open:
        pend = pop_pending_for_market("KR", 10)
        execute_signals("KR", pend + [normalize_signal_market_and_ticker(s) for s in kr_sigs if isinstance(s, dict)])
    if us_open:
        pend = pop_pending_for_market("US", 10)
        execute_signals("US", pend + [normalize_signal_market_and_ticker(s) for s in us_sigs if isinstance(s, dict)])

def execute_signals(market: str, sig_list):
    # None ì œê±°/ì •ê·œí™”
    norms = []
    for s in sig_list:
        if not s:
            continue
        if isinstance(s, dict) and "market" in s and "ticker" in s:
            norms.append(s)

    norms.sort(key=lambda x: x.get("score", 0), reverse=True)
    obs_inc("EXECUTE_IN", len(norms))

    BUY_SCORE_MIN = 82  # ë””ë²„ê·¸ ë‹¨ê³„: 82~85 ê¶Œì¥ (ì•ˆì •í™” í›„ 88~92ë¡œ ìƒí–¥)

    for norm in norms[:8]:
        obs_inc("CANDIDATE_SEEN")

        m = norm["market"]
        if m != market:
            obs_drop("BLOCKED_MARKET_MISMATCH", m, norm.get("ticker"), norm.get("score"))
            continue

        ticker = norm["ticker"]
        score = norm.get("score", 0)
        reason = norm.get("reason", "")
        ttype = norm.get("trade_type", "SWING")
        exch = norm.get("exch")

        # 1) ìµœì†Œ ì ìˆ˜ ì»·
        if score < 80:
            obs_drop("BLOCKED_SCORE_LT80", m, ticker, score)
            continue

        # 2) í¬ì§€ì…˜ í•œë„
        if ticker not in PORTFOLIO and len(PORTFOLIO) >= MAX_POSITIONS:
            obs_drop("BLOCKED_MAX_POSITIONS", m, ticker, score, {"pos": len(PORTFOLIO)})
            continue

        # 3) ê¸°ìˆ ë¶„ì„
        tech = analyze_technicals(m, ticker)
        if not tech:
            obs_drop("BLOCKED_TECH_NONE", m, ticker, score)
            continue
        obs_inc("TECH_OK")

        # -------------------------
        # (V33.1 ë³‘ëª© í•´ê²°) OB í•˜ë“œí•„í„° ì œê±° -> ì†Œí”„íŠ¸ ìŠ¤ì½”ì–´í™”
        # -------------------------
        soft_score = float(score)

        in_ob = bool(tech.get("in_ob"))
        rsi = tech.get("rsi")

        # OB: ê°€ì /ê°ì 
        soft_score += 8 if in_ob else -6

        # RSI ê³¼ì—´ ì•½ê°„ ê°ì (ë„ˆë¬´ ê°•í•˜ê²Œ í•˜ì§€ ë§ ê²ƒ)
        if isinstance(rsi, (int, float)) and rsi > 78:
            soft_score -= 8

        if soft_score < BUY_SCORE_MIN:
            obs_drop("BLOCKED_SOFT_SCORE", m, ticker, score, {"soft": soft_score, "in_ob": in_ob, "rsi": rsi})
            continue
        obs_inc("SCORE_OK")

        # 4) ê°€ê²© êµì°¨ê²€ì¦
        px, yf_p, kis_p, gap = get_price_hybrid(m, ticker, exch)
        if px is None:
            obs_drop("BLOCKED_PX_NONE_HARD_GUARD", m, ticker, score, {"yf": yf_p, "kis": kis_p, "gap": gap})
            log_ai_thought(m, ticker, score, "SKIP", ttype, reason,
                           source="LATENCY_GUARD", yf_price=yf_p, kis_price=kis_p, gap=gap,
                           note="ê´´ë¦¬ ê³¼ëŒ€(HARD) â†’ ì£¼ë¬¸ ìŠ¤í‚µ")
            continue
        obs_inc("PX_OK")

        # ì‹œíŠ¸ ë¡œê·¸(ê²°ì • ê·¼ê±° ë‚¨ê¸°ê¸°)
        log_ai_thought(
            m, ticker, soft_score, "TRADE-CHECK", ttype, reason,
            source="HYBRID_PRICE", yf_price=yf_p, kis_price=kis_p, gap=gap,
            note=f"soft_score={soft_score} | in_ob={in_ob} | rsi={rsi}"
        )

        # 5) BUY_TRIGGER
        obs_inc("BUY_TRIGGER")
        print(f"ğŸš€ BUY_TRIGGER: m={m} t={ticker} score={score} soft={soft_score:.1f} px={px} in_ob={in_ob} rsi={rsi} gap={gap}")

        # (ì±… ë°˜ì˜) ë¹„ë¡€ë°°ë¶„ + (US) ë³€ë™ì„± íƒ€ê²ŸíŒ…
        amt = calc_amount_proportional(soft_score, m)

        place_order_scaled(
            m, ticker, "BUY", px, exch=exch,
            strategy=f"AI(S{int(soft_score)})",
            reason=f"{reason} | SEL:AI | SIZ:PROP | TIM:OB{int(in_ob)} RSI{int(rsi) if rsi else ''} GAP{round(gap*100,2) if gap else ''}",
            base_amount=amt,
            trade_type=ttype
        )

    obs_maybe_print()

# ==============================================================================
# [15] ì‹¤í–‰
# ==============================================================================
if __name__ == "__main__":
    print(f"ğŸ”¥ {VERSION} ê°€ë™ ì‹œì‘ (KIS_ENV={KIS_ENV}, DRY_RUN={DRY_RUN})")

    initialize_sheet()
    load_ticker_config()  # âœ… Ticker_Info ì‹œíŠ¸ì—ì„œ ë§¤ë§¤ íŒŒë¼ë¯¸í„° ë¡œë”©
    load_kr_tickers()
    load_state()

    # ìŠ¤ì¼€ì¤„
    schedule.every(2).minutes.do(main_engine_cycle)
    main_engine_cycle()  # BOOT_RUN
    schedule.every(1).minutes.do(manage_positions_cycle)
    schedule.every(5).minutes.do(save_state)

    while True:
        try:
            schedule.run_pending()
            time.sleep(1)
        except KeyboardInterrupt:
            print("ğŸ›‘ ìˆ˜ë™ ì¢…ë£Œ ìš”ì²­")
            save_state()
            break
        except Exception as e:
            print(f"âš ï¸ ë©”ì¸ ë£¨í”„ ì—ëŸ¬: {e}")
            send_telegram(f"âš ï¸ ë©”ì¸ ë£¨í”„ ì—ëŸ¬ ë°œìƒ: {e}")
            time.sleep(5)